package com.webdevils.display {	import flash.display.*;	import flash.events.*;	import flash.geom.*;	import flash.utils.*;		public class ImageStreak extends BasicLoader {		public static const TRANSITION_FINISHED:String = "transitionfinished";		private var source_bitmapdata:BitmapData;		private var dest_bitmapdata:BitmapData;		private var display_bitmap:Bitmap;				private var image_width:Number;		private var image_height:Number;		private var col:uint;				private var time:uint;				public function ImageStreak( url:String = null, _time:uint = 1 ) {			col = 0;			time = _time;			if ( url != null ) {				load( url );			}		}				protected override function on_complete( e:Event ):void {			dispatchEvent( new Event( e.type, e.bubbles, e.cancelable ) );			var loader 	 = e.target;			image_width  = loader.content.width;			image_height = loader.content.height						if ( loader.content is Bitmap ) {				source_bitmapdata = Bitmap( loader.content ).bitmapData;			} else {				source_bitmapdata = new BitmapData( image_width, image_height );				source_bitmapdata.draw( loader.content );			}						dest_bitmapdata   	= new BitmapData( image_width, image_height, false, 0x000000 );			display_bitmap		= new Bitmap( dest_bitmapdata );			addChild( display_bitmap );						var t:Number = Math.ceil( time / image_width * 1000 );			var timer:Timer = new Timer( t, image_width );			timer.addEventListener( TimerEvent.TIMER, on_enterframe );			timer.start();		}				private function on_enterframe( e:Event ):void {			for ( var row:uint = 0; row < image_height; row++ ) {				var rect = new Rectangle( col, row, image_width - col, 1 );				var color = source_bitmapdata.getPixel32( col, row );				dest_bitmapdata.fillRect( rect, color );			}			col++;			if ( col > image_width ) {				e.target.removeEventListener( TimerEvent.TIMER, on_enterframe );				// swap bitmap for swf			}		}	}}