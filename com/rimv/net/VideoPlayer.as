package com.rimv.net {	import fl.controls.*;	import fl.events.SliderEvent;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.*;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.NetStatusEvent;	import flash.events.TimerEvent;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.Timer;	import flash.text.*;	import caurina.transitions.Tweener;	import fl.transitions.*; 	import fl.transitions.easing.*;	public class VideoPlayer extends Sprite {		/**		 * The amount of time between calls to update the playhead timer, in 		 * milliseconds.		 */		public const PLAYHEAD_UPDATE_INTERVAL_MS:uint = 10;		public const DISPLAY_TIMER_UPDATE_DELAY:uint = 300;		/**		 * The path to the XML file containing the video playlist.		 */		public const PLAYLIST_XML_URL:String = "information.xml";		/**		 * The client object to use for the NetStream object.		 */		public var client:Object;		/**		 * The index of the currently playing video.		 */		public var idx:uint = 0;		/**		 * A copy of the current video's metadata object.		 */		public var meta:Object;		public var nc:NetConnection;		public var ns:NetStream;		public var playlist:XML;		public var t:Timer;		public var uldr:URLLoader;		public var vid:Video;		public var videosXML:XMLList;		public var myPlayer:player = new player;		public var play_button:playBut=new playBut;		public var pause_button:pauseBtn=new pauseBtn;		public var myContent:controls=new controls;		public var captions:Array = new Array;		public var desc:Array = new Array;		public var head:Array = new Array;		public var pBar:ProgressBar=new ProgressBar;		public var mySlider:Slider=new Slider;		public var volume:volume_holder = new volume_holder;		public var fullest:full_screen = new full_screen;		public var fullback:full_back = new full_back;		public var replay:replay_button = new replay_button;		public var myLabel:Label=new Label;		/*public var tBar:whiteBar=new whiteBar;		public var bBar:whiteBar=new whiteBar;*/		public var cap:TextField = new TextField();		public var dek:TextField = new TextField();		public var nav:TextField = new TextField();		public var fadeTime:Number=.15;				//121208 addition		public var photoContainer:MovieClip = new MovieClip();		public var curImg:Number;		public var tempImg:Number;		public var imgCount:Number;		public var slideURLs:Array=new Array;						/**		 * The SoundTransform object used to set the volume for the NetStream.		 */		public var volumeTransform:SoundTransform;		/**		 * Constructor		 */		public function VideoPlayer() {			// Initialize the uldr variable which will be used to load the external 			// playlist XML file.			uldr = new URLLoader();			uldr.addEventListener(Event.COMPLETE, xmlCompleteHandler);			uldr.load(new URLRequest(PLAYLIST_XML_URL));		}		/**		 * Once the XML file has loaded, parse the file contents into an XML object, 		 * and create an XMList for the video nodes in the XML.		 */		public function xmlCompleteHandler(event:Event):void {			playlist = XML(event.target.data);			videosXML = playlist.item;			main();		}				public function ifFailed(e:Event):void{			trace("ERROR");		}		/**		 * The main application.		 */		public function main():void {						volumeTransform = new SoundTransform();			// Create the client object for the NetStream, and set up a callback			// handler for the onMetaData event.			client = new Object();			client.onMetaData = metadataHandler;			nc = new NetConnection();			nc.connect(null);			// Initialize the NetSteam object, add a listener for the netStatus 			// event, and set the client for the NetStream.			ns = new NetStream(nc);			ns.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);			ns.client = client;			// Initialize the Video object, attach the NetStram, and add the Video			// object to the display list.			vid = new Video();            vid.x = stage.stageWidth/2; //900-704            vid.y = stage.stageHeight/2;			vid.attachNetStream(ns);			addChild(vid);						// display the thumbnails from when movie first loads			//showThumbs();						playVideo();									// Initialize the Timer object and set the delay to			// PLAYHEAD_UPDATE_INTERVAL_MS milliseconds. 			t = new Timer(PLAYHEAD_UPDATE_INTERVAL_MS);			t.addEventListener(TimerEvent.TIMER, timerHandler);			// Configure the pBar ProgressBar instance and set the mode to			// MANUAL. Progress  bar values will be explicitly set using the			// setProgress() method.			pBar.mode = ProgressBarMode.MANUAL;			// Configure the mySlider Slider component instance. The maximum 			// value is set to 1 because the volume in the SoundTransform object 			// is set to a number between 0 and 1. The snapInterval and tickInterval 			// properties are set to 0.1 which allows users to set the volume to 			// 0, 0.1 - 0.9, 1.0 which allows users to increment or decrement the 			// volume by 10%.			mySlider.value = volumeTransform.volume;			mySlider.minimum = 0;			mySlider.maximum = 1;			mySlider.snapInterval = 0.1;			mySlider.tickInterval = mySlider.snapInterval;			// Setting the liveDragging property to true causes the Slider 			// instance's change event to be dispatched whenever the slider is 			// moved, rather than when the user releases the slider thumb.			mySlider.liveDragging = true;			mySlider.addEventListener(SliderEvent.CHANGE, volumeChangeHandler);		}		/**		 * Event listener for the mySlider instance. Called when the user 		 * changes the value of the volume slider.		 */		public function volumeChangeHandler(event:SliderEvent):void {			// Set the volumeTransform's volume property to the current value of the 			// Slider and set the NetStream object's soundTransform property.			volumeTransform.volume = event.value;			ns.soundTransform = volumeTransform;		}		/**		 * Event listener for the ns object. Called when the net stream's status 		 * changes.		 */		public function netStatusHandler(event:NetStatusEvent):void {			try {				switch (event.info.code) {					case "NetStream.Play.Start" :						// If the current code is Start, start the timer object.						t.start();						break;					case "NetStream.Play.StreamNotFound" :					case "NetStream.Play.Stop" :						// If the current code is Stop or StreamNotFound, stop 						// the timer object and play the next video in the playlist.						t.stop();						playNextVideo();						break;				}			} catch (error:TypeError) {				// Ignore any errors.			}		}		/**		 * Event listener for the ns object's client property. This method is called 		 * when the net stream object receives metadata information for a video.		 */		public function metadataHandler(metadataObj:Object):void {			// Store the metadata information in the meta object.			meta = metadataObj;			// Resize the Video instance on the display list with the video's width 			// and height from the metadata object.			vid.width = meta.width;			vid.height = meta.height;		}				//next image button		public function onBtnClick(e:Event):void {						TransitionManager.start(photoContainer, {type:Fade, direction:Transition.OUT, duration:1, easing:Strong.easeOut});			playVideo();			trace(e.target);					}					/**		 * Retrieve the current video from the playlist XML object.		 */		public function getVideo():String {						/*for(var idx = 0;idx<videosXML.length();idx++){ //can't seem to get this function to work								slideURLs.push(videosXML.video.url.text()[idx]);			}*/						return videosXML[idx].caption.text();			trace(videosXML[idx].caption.text());		}		/**		 * Play the currently selected video.		 */		public function playVideo():void {						var url:String = getVideo();			ns.play(url);			createDek();					}						/**		 * Decrease the current video index and begin playback of the video.		 */		public function playPreviousVideo():void {			if (idx > 0) {				idx--;				playVideo();				// Make sure the pBar progress bar is visible.				pBar.visible = true;			}		}				/**		 * Increase the current video index and begin playback of the video.		 */		public function playNextVideo():void {			if (idx < (videosXML.length() - 1)) {				// If this is not the last video in the playlist increase the 				// video index and play the next video.				idx++;				playVideo();				// Make sure the pBar progress bar is visible.				pBar.visible = true;							} else {				// If this is the last video in the playlist increase the video				// index, clear the contents of the Video object and hide the 				// pBar progress bar. The video index is increased so that 				// when the video ends, clicking the prev_button will play the 				// correct video.				idx++;				hideDek();				vid.clear();				pBar.visible = false;				Tweener.addTween(myPlayer, {alpha:1, y: myPlayer.y-200, time:1.5, transition: "easeOutBounce"});			}		}				public function videoReturn(e:Event):void {				if (idx >= (videosXML.length())) {				idx = 0;				playVideo();				pBar.visible = true;				Tweener.addTween(myPlayer, {alpha:.5, x: myPlayer.x+595, time:1.5, transition: "easeOut"});			}		}				//description for video title		public function createDek():void{						addChild(myContent);			addChild(play_button);			addChild(pause_button);			addChild(fullback);			addChild(volume);			addChild(mySlider);			addChild(pBar);			addChild(fullest);			addChild(replay);						myContent.x = 356;			myContent.y = 385;			pause_button.x = 88;			pause_button.y = 385;			pause_button.buttonMode = true;			pause_button.visible = true;			play_button.x = 88;			play_button.y = 385;			play_button.buttonMode = true;			play_button.visible = false;			play_button.alpha = .7;			pBar.x = 118;			pBar.y = 385;			pBar.width = 300;			pBar.height = 15;			mySlider.x = 473;			mySlider.y = 385;			mySlider.height = 3;			mySlider.buttonMode = true;			volume.x = 513;			volume.y = 385;			volume.width = 90;			volume.height = 5;			volume.alpha = .2;			volume.buttonMode = true;			fullest.x = 483;			fullest.y = 385;			fullest.alpha = .2;			fullest.buttonMode = true;			fullback.x = 513;			fullback.y = 385;			replay.x = stage.stageWidth/2+5;			replay.y = stage.stageHeight/2;			replay.buttonMode = true;			replay.visible = true;			replay.alpha = 0;						Tweener.addTween(myContent, {alpha:1, y: myContent.y-80, time:1.5, transition: "easeInOutElastic", delay: .5});			Tweener.addTween(pause_button, {alpha:.7, y: pause_button.y-78, time:1.5, transition: "easeInOutElastic", delay: .5});			Tweener.addTween(mySlider, {alpha:.85, y: mySlider.y-81, time:1.5, transition: "easeInOutElastic", delay: .5});			Tweener.addTween(pBar, {alpha:.7, y: pBar.y-90, time:1.5, transition: "easeInOutElastic", delay: .5});			Tweener.addTween(volume, {alpha:.2, y: volume.y-75, time:1.5, transition: "easeInOutElastic", delay: .5});			Tweener.addTween(fullest, {alpha:.4, y: fullest.y-170, time:1.5, transition: "easeInOutElastic", delay: .5});			Tweener.addTween(fullback, {alpha:.35, y: fullback.y-83, time:1.5, transition: "easeInOutElastic", delay: .5});									// Configure the various Button instances. Each Button instance uses 			// the same click handler.			play_button.addEventListener(MouseEvent.CLICK, buttonClickHandler);			pause_button.addEventListener(MouseEvent.CLICK, buttonClickHandler);			fullest.addEventListener(MouseEvent.CLICK, goFull);		} 				public function hideDek():void {						Tweener.addTween(myContent, {alpha:1, y: myContent.y+80, time:1.5, transition: "easeInOutElastic"});			Tweener.addTween(pause_button, {alpha:.7, y: pause_button.y+78, time:1.5, transition: "easeInOutElastic"});			Tweener.addTween(mySlider, {alpha:.85, y: mySlider.y+81, time:1.5, transition: "easeInOutElastic"});			Tweener.addTween(pBar, {alpha:.7, y: pBar.y+90, time:1.5, transition: "easeInOutElastic"});			Tweener.addTween(volume, {alpha:.2, y: volume.y+75, time:1.5, transition: "easeInOutElastic"});			Tweener.addTween(fullest, {alpha:.4, y: fullest.y+170, time:1.5, transition: "easeInOutElastic"});			Tweener.addTween(fullback, {alpha:.35, y: fullback.y+83, time:1.5, transition: "easeInOutElastic"});			Tweener.addTween(replay, {alpha:1, time:2, transition: "easeInOutElastic"});			//replay.visible = true;			replay.x = stage.stageWidth/2;			replay.y = stage.stageHeight/2;			replay.addEventListener(MouseEvent.CLICK, buttonClickHandler);					}						public function goFull(e:Event):void {						setFullScreen();					}				public function setFullScreen():void {			if (stage.displayState== "normal") {				stage.displayState="fullScreen";				//stage.scaleMode = StageScaleMode.NO_SCALE;				} else {				stage.displayState="normal";			}					}				/**		 * Click handler for each of the video playback buttons.		 */		public function buttonClickHandler(event:MouseEvent):void {			// Use a switch statement to determine which button was clicked.			switch (event.currentTarget) {				case play_button :					// If the play button was clicked, resume the video playback. 					// If the video was already playing, this has no effect.					ns.resume();					play_button.visible = false;					pause_button.x = 88;					pause_button.y = 307;					pause_button.visible = true;					pause_button.buttonMode = true;					Tweener.addTween(pause_button, {alpha:.7, time:1.0, transition: "easeInOutElastic", delay: .5});					//playVideo();					break;				case pause_button :					// If the pause button was clicked, pause the video playback. 					// If the video was already playing, the video will be paused. 					// If the video was already paused, the video will be resumed.					ns.togglePause();					pause_button.visible = false;					play_button.x = 88;					play_button.y = 307;					play_button.visible = true;					play_button.buttonMode = true;					Tweener.addTween(play_button, {alpha:.7, time:1.0, transition: "easeInOutElastic", delay: .5});					break;				case replay :					// If the play button was clicked, resume the video playback. 					// If the video was already playing, this has no effect.					playPreviousVideo();					break;			}		}		/**		 * Event handler for the timer object. This method is called every 		 * PLAYHEAD_UPDATE_INTERVAL_MS milliseconds as long as the timer is running.		 */		public function timerHandler(event:TimerEvent):void {			try {				// Update the progress bar and label based on the amount of video				// that has played back.				pBar.setProgress(ns.time, meta.duration);				myLabel.text = ns.time.toFixed(1) + " of " + meta.duration.toFixed(1) + " seconds";				var format:TextFormat = new TextFormat();				format.color = 0xCCCCCC;						} catch (error:Error) {				// Ignore this error.			}		}	}}